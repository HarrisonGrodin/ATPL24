\documentclass[letterpaper]{article}

\input{setup}
\input{defns}

\usepackage{newunicodechar}
\newunicodechar{λ}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{→}{\ensuremath{\mathrel\to}}
\newunicodechar{⊢}{\ensuremath{\mathrel\vdash}}
\newunicodechar{∀}{\ensuremath{\mathnormal\forall}}
\newunicodechar{∃}{\ensuremath{\mathnormal\exists}}
\newunicodechar{Γ}{\ensuremath{\mathnormal\Gamma}}

\title{15-791 ATPL \\ Week 8 Notes}
\author{Tesla Zhang, Jason Yao}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}
Last week we introduced the lax framework of computation type.
This week, we introduce another approach to stratify value types and computation types,
called \emph{call-by-push-value} (CBPV), or polarization.

Instead of introducing a type former for computation types,
we maintain the distinction between type structures instead.
We consider positive types \emph{values types}, which we denote as $A^+$,
and negative types \emph{computation types}, which we denote as $A^-$.
Similar to adjoint logic, we link these two families of types with an adjunction.

The syntax of types in CBPV is given by the following grammar:

\section{IO Effects}
We can represent various effects using CBPV as the framework. Here, we represent simple IO with printing to standard out and reading from standard in.


\subsection{Statics}
Assume we have some type $\kw{string}$. We add the following typing rules to CBPV:

\begin{mathpar}
  \defrule[T-Print][sta:print]
  {\Gamma \entails{\isOfTp{s}{\kw{string}}}}
  {\Gamma \entails{\isOfTp{\kw{print}(s)}{\freeTy{\topTy}}}}

  \defrule[T-Read][sta:read]
  {\strut}
  {\Gamma \entails{\isOfTp{\kw{read}}{\freeTy{\kw{string}}}}}
\end{mathpar}

\subsection{Dynamics}

For values, we use the typical evaluation semantics where $V \evalsTo[] V_0$ for some fully evaluated value $V_0$.

For computations, we describe a configuration/state transition system based on a simplified process calculus. 

We have three processes $\cal I$, $\cal O$, and $C$ running in parallel composition, written as 
${\cal I} \parallel {\cal O} \parallel C$. $\cal I$ and $\cal O$ are the input and output processes, respectively, and are represented as lists of \kw{string}s. $C$ is the current running computation.

We also have two channels \kw{stdin} and \kw{stdout} which carry data of type \kw{string}.

\subsubsection{Transitions}
\todo{Needed to use \kw{s} in the step actions instead since $s$ shows up as $\int$ for some reason}
\begin{mathpar}
  \defrule[D-Input][dyn:input]
    {\strut}
    {\consEx*{s}{\cal I} \stepsTo<\sndAc*{\kw{stdin}}{\kw{s}}> {\cal I}}

  \defrule[D-Output][dyn:output]
    {\strut}
    {{\cal O} \stepsTo<\rcvAc*{\kw{stdout}}{\kw{s}}> \consEx*{s}{\cal O}} 

  \defrule[D-Print][dyn:print]
    {\strut}
    {\kw{print}(s) \stepsTo<\sndAc*{\kw{stdout}}{\kw{s}}> {\retEx*{\unitEx*}}}

  \defrule[D-Read][dyn:read]
    {\strut}
    {\kw{read} \stepsTo<\rcvAc*{\kw{stdin}}{\kw{s}}> {\retEx*{s}}}

  \defrule[D-Par][dyn:par]
    {S_1 \stepsTo<\alpha> S_1' \\
     S_2 \stepsTo<\overline{\alpha}> S_2'}
    {S_1 \parallel S_2 \stepsTo S_1' \parallel S_2'} 
\end{mathpar}

\subsection{Equations}

\section{Mutable State}

\subsection{Grammar}
\subsection{Statics}
\subsection{Dynamics}
\subsection{Equations}

\end{document}
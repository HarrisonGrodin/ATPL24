\documentclass[letterpaper]{article}

\input{setup}
\input{defns}

\usepackage{newunicodechar}
\newunicodechar{∀}{\ensuremath{\mathnormal\forall}}
\newunicodechar{∃}{\ensuremath{\mathnormal\exists}}
\newunicodechar{Γ}{\ensuremath{\mathnormal\Gamma}}

\NewDocumentCommand{\memState}{m m}{\left\{ #1 \parallel #2 \right\}}
\NewDocumentCommand{\mapsVal}{m m}{#1 \hookrightarrow #2}
\NewDocumentCommand{\letvEx}{m m m}{\Abt{\Opn{letv}}(#1;\Abs<#2>{#3})}
\NewDocumentCommand{\eqExact}{m m m}{#1 \doteq #2 \in #3}

\title{15-791 ATPL \\ Week 8 Notes}
\author{Tesla Zhang, Jason Yao}
\date{\today}

\begin{document}
\maketitle

\section{Call-by-Push-Value (CBPV)}
Last week we introduced the lax framework of computation type.
This week, we introduce another approach to stratify value types and computation types,
called \emph{call-by-push-value} (CBPV), or \emph{polarization}.

Instead of introducing a type former for computation types,
we maintain the distinction between type structures instead.
We consider positive types \emph{values types}, which we denote as $A$,
and negative types \emph{computation types}, which we denote as $X$.
The polarity here is related to the polarity of the corresponding connectives in linear logic.
Similar to adjoint logic, we link these two families of types with an adjunction,
where the computation fragment is similar to the linear fragment in adjoint logic.

The syntax of types in CBPV is given by the following grammar:

\[
    \begin{array}{rcl}
        \text{Computation types} \quad & X ::= & \prodTy*{X_1}{X_2} \mid \parrTy*{A_1}{X_2} \mid F(A) \\
        \text{Value types} \quad       & A ::= & \topTy* \mid \tensorTy*{A_1}{A_2} \mid \sumTy*{A_1}{A_2} \mid U(X) \\
    \end{array}
\]

For simplicity, we introduce the function type only as a computation type,
and for products, we introduce both versions, corresponding to the nature of the product that
it can be used positively or negatively.

\subsection{Statics}

The static semantics of CBPV is defined by the following judgment given by the following typing rules:

\begin{mathpar}
\end{mathpar}

\section{I/O Effects}
We can represent various effects using CBPV as the underlying framework. Here, we introduce simple I/O effects with printing and reading.

\subsection{Grammar}
We introduce a new base type $\kw{string}$. We also introduce two new commands, $\kw{print}$ and $\kw{read}$, which respectively print a string to standard out and read a string from standard in.

\[
    \begin{array}{rl} 
        A ::= & \cdots \mid \kw{string} \\
        C ::= & \cdots \mid \kw{print}(V) \mid \kw{read} 
    \end{array}
\]

\subsection{Statics}
We add the following typing rules for the new commands. Assume that \kw{string} has some sensible typing rules, we just use it as the type we can print/read.

\begin{mathpar}
  \defrule[T-Print][sta:print]
  {\Gamma \entails{\isOfTp{s}{\kw{string}}}}
  {\Gamma \entails{\isOfTp{\kw{print}(s)}{\freeTy{\topTy}}}}

  \defrule[T-Read][sta:read]
  {\strut}
  {\Gamma \entails{\isOfTp{\kw{read}}{\freeTy{\kw{string}}}}}
\end{mathpar}

\subsection{Dynamics}

For values, we use the typical evaluation semantics where $V \evalsTo V_0$ for some fully evaluated value $V_0$.

For computations, we describe a configuration/state transition system based on a simplified process calculus. We have three processes $\cal I$, $\cal O$, and $C$ running in parallel composition, written as
${\cal I} \parallel {\cal O} \parallel C$. $\cal I$ and $\cal O$ are the input and output processes, respectively, and are represented as lists of \kw{string}s. $C$ is the current running computation.

Note that configurations are unique up to structural congruence, so the processes can be freely reordered/nested/etc. as necessary for the dynamics rules to apply (e.g.  ${\cal I} \parallel {\cal O} \parallel C \equiv {\cal I} \parallel C \parallel {\cal O} \equiv {\cal I} \parallel \left( {\cal O} \parallel C \right)$ ).

Finally, we also have two channels \kw{stdin} and \kw{stdout} which carry data of type \kw{string}.

\subsubsection{Transitions}
We present a subset of the state transitions:
\todo{Needed to use \kw{s} in the step actions instead since $s$ shows up as $\int$ for some reason}
\begin{mathpar}
  \defrule[D-Input][dyn:input]
  {\strut}
  {\consEx*{s}{\cal I} \stepsTo<\sndAc*{\kw{stdin}}{\kw{s}}> {\cal I}}

  \defrule[D-Output][dyn:output]
  {\strut}
  {{\cal O} \stepsTo<\rcvAc*{\kw{stdout}}{\kw{s}}> \consEx*{s}{\cal O}}

  \defrule[D-Print][dyn:print]
  {\strut}
  {\kw{print}(s) \stepsTo<\sndAc*{\kw{stdout}}{\kw{s}}> {\retEx*{\unitEx*}}}

  \defrule[D-Read][dyn:read]
  {\strut}
  {\kw{read} \stepsTo<\rcvAc*{\kw{stdin}}{\kw{s}}> {\retEx*{s}}}

  \defrule[D-Single][dyn:single]
  {S_1 \stepsTo<\alpha> S_1'}
  {S_1 \parallel S_2 \stepsTo<\alpha> S_1' \parallel S_2}

  \defrule[D-Par][dyn:par]
  {S_1 \stepsTo<\alpha> S_1' \\
    S_2 \stepsTo<\overline{\alpha}> S_2'}
  {S_1 \parallel S_2 \stepsTo S_1' \parallel S_2'}

\end{mathpar}
Note that rule \ruleref{dyn:par} relies on the definition of $\overline{\alpha}$ representing the complementary action of $\alpha$. In this case, $\sndAc*{a}{s}$, the action to send $s$ over channel $a$, and $\rcvAc*{a}{s}$, the action to receive $s$ over channel $a$, are complementary to each other.

The dynamics for I/O are relatively straightforward. If ${\cal I}$ is not empty and the program commands a \kw{read}, \ruleref{dyn:par} allows the overall configuration to take a step by pairing \ruleref{dyn:input} and \ruleref{dyn:read}. Similarly, if the program wishes to \kw{print}, \ruleref{dyn:output} and \ruleref{dyn:print} will apply concurrently.

\ruleref{dyn:single} allows the program to take steps not pertaining to I/O according to the base CBPV dynamics. In this case $\alpha$ would be $\epsilon$, the silent action.

\todo{Not sure how much of this to mention/is this extraneous detail? \ruleref{dyn:single} wasn't in the lecture, but I felt it was necessary to mention to show that the rest of the program can still run without needing to send messages}
Note that this rule also allows for asynchronous sends since a process could perform an action $\sndAc*{a}{s}$ without a complementary receive. This is not an issue since we can view channels as a message queue, so any asynchronous send just adds its message to the queue. Reads must still be synchronous since there must be a value available on the queue to use in the rest of the program.

\subsection{Equations}
We present a few select equations:
\begin{mathpar}

  \defrule[E-Print-Fun][eq:print-fun]
  {\Gamma \entails{\isOfTp{s}{\kw{string}}} \\
    \Gamma, \isOfTp{x}{A} \entails{\isOfTp{C}{X}}}
  {\Gamma \entails{\seqCmd*{\kw{print}(s)}{\lamEx*{x}{C} \equiv \lamEx*{x}{\seqCmd*{\kw{print}(s)}{C}}}} : \parrTy*{A}{X}}

  \defrule[E-Read-Fun][eq:read-fun]
  { \Gamma, \isOfTp{s}{\kw{string}}, \isOfTp{x}{A} \entails{\isOfTp{C}{X}}}
  {\Gamma \entails{\fletEx*{\kw{read}}{s}{\lamEx*{x}{C} \equiv \lamEx*{x}{\fletEx*{\kw{read}}{s}{C}}}} : \parrTy*{A}{X}}

  \defrule[E-Print-Bind][eq:print-bind]
  {\Gamma \entails{\isOfTp{s}{\kw{string}}} \\
   \Gamma \entails{\isOfTp{C_1}{\freeTy{A_1}}} \\
   \Gamma, \isOfTp{x}{A_1} \entails{\isOfTp{C_2}{X_2}}}
  {\Gamma \entails{\fletEx*{\left( \seqCmd*{\kw{print}(s)}{C_1} \right)}{x}{C_2} \equiv \seqCmd*{\kw{print}(s)}{\fletEx*{C_1}{x}{C_2}}} : X_2}

  \defrule[E-Read-Bind][eq:print-bind]
  {\Gamma, \isOfTp{s}{\kw{string}} \entails{\isOfTp{C_1}{\freeTy{A_1}}} \\
   \Gamma, \isOfTp{x}{A_1} \entails{\isOfTp{C_2}{X_2}}}
  {\Gamma \entails{\fletEx*{\left( \fletEx*{\kw{read}}{s}{C_1} \right)}{x}{C_2} \equiv \fletEx*{\kw{read}}{s}{\fletEx*{C_1}{x}{C_2}}} : X_2}

\end{mathpar}
Note that rules \ruleref{eq:print-fun} and \ruleref{eq:read-fun} say that performing I/O before a function definition is equivalent to performing I/O within the function definition. This might be surprising, since one could imagine that the RHS would not be guaranteed to perform the I/O if the function is not applied. However, we will soon see how to justify this through exact equality.

\subsection{Exact Equality}

\todo{This definition changed...}
This section presented during lecture has been updated, so we will present a higher-level overview of exact equality.

Exact equality between terms $\eqExact{V}{V'}{A}$ is defined as always by induction on $A$ using evaluation dynamics. Essentially, valuable terms are exactly equal if they evaluate to values whose constituent parts are exactly equal. At the base types, they are equal if they are the same value.

For computations $\eqExact{C}{C'}{X}$, we essentially want their behavior to be the same. If the computations return a value, then we want the values to be exactly equal \emph{and} the I/O behavior should be the same. However, if they result in another computation, we \emph{do not} require the I/O behavior to be the same, allowing for the discrepancy seen before in rules \ruleref{eq:print-fun} and \ruleref{eq:read-fun}. This is since ultimately, we only care about the final result of the computation, so intermediate I/O descrepancies are not important.

\section{Mutable State}
We also consider store effects using CBPV. For simplicity, we represent mutable state with a set of predefined assignables.

\subsection{Grammar}
We add two new commands, \kw{get} and \kw{set}, which respectively read and write to memory.
\[
    \begin{array}{rl} 
        C ::= & \cdots \mid \getCmd<a> \mid \setCmd<a>{V}
    \end{array}
\]
Here, $a$ is an assignable, which is essentially a unique identifier for a memory location.

\subsection{Statics}
We introduce a new context $\Sigma$ for assignables that maps assignables to their types. Since we are only considering a predefined set of assignables, $\Sigma$ is fxed.
\[
  \Sigma = \hasTp{a_1}{A_1}, \ldots,\, \hasTp{a_n}{A_n}
\]
Note that each type $A_i$ must be \emph{ground}. A ground type is essentially any value type $A$ \emph{except} $\thunkTy{X}$. If we allowed $\thunkTy{X}$, we would be able to store computations in memory, which allows for partiality through backpatching. We'll see next week that the definition for exact equality is not well formed if there were no restrictions on the types of assignables.

We add the following typing rules for the new commands:
\begin{mathpar}
  \defrule[T-Get][sta:get]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \left( A\, {\sf ground} \right)}
  {\Gamma \entails[\Sigma]{\isOfTp{\getCmd<a>}{\freeTy{A}}}}

  \defrule[T-Set][sta:set]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \left( A\, {\sf ground} \right) \\
    \Gamma \entails[\Sigma]{\isOfTp{V}{A}}}
  {\Gamma \entails[\Sigma]{\isOfTp{\setCmd<a>{V}}{\freeTy{A}}}}
\end{mathpar}
Note that $\setCmd<a>{V}$ returns the value $V$ that was written to memory, instead of just $\unitEx*$.

\subsection{Dynamics}
For values, we again use the typical evaluation semantics where $V \evalsTo[\Sigma] V_0$ for some fully evaluated value $V_0$.

For computations, we have a state transition system where states $\memState{\mu}{C}$ consist of a memory $\mu$ and the current running computation $C$.

$\mu$ is composed of cells mapping assignables to values:
\[
  \mu = \mapsVal{a_1}{V_1} \parallel \cdots \parallel \mapsVal{a_n}{V_n}
\]
For each cell $1 \le i \le n$, we have $\Sigma \entails{\hasTp{a_i}{A_i}}$ and $\Sigma \entails[\varepsilon]{\isOfTp{V_i}{A_i}}$. Note that the empty assignable context $\varepsilon$ is used to indicate $V_i$ cannot reference any memory.

\subsubsection{Transitions}
We present a subset of the state transitions:

\begin{mathpar}
  \defrule[D-Get][dyn:get]
  {\strut}
  {\memState{\mu \parallel \mapsVal{a}{V}}{\getCmd<a>} \stepsTo[\Sigma, \hasTp{a}{A}] \memState{\mu \parallel \mapsVal{a}{V}}{\retEx*{V}}}

  \defrule[D-Set][dyn:set]
  {V \evalsTo[\Sigma] V_0}
  {\memState{\mu \parallel \mapsVal{a}{\_}}{\setCmd<a>{V}} \stepsTo[\Sigma, \hasTp{a}{A}] \memState{\mu \parallel \mapsVal{a}{V_0}}{\retEx*{V_0}}}
\end{mathpar}

\subsection{Equations}
We have the following equations that allow us to ``normalize'' \kw{set} and \kw{get} commands to a sequence of \kw{get}s followed by a \kw{sets}:

\begin{mathpar}

  \defrule[E-Set-Get-Same][eq:set-get-same]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \Gamma \entails[\Sigma]{\isOfTp{V}{A}}}
  {\Gamma \entails[\Sigma]{\seqCmd*{\setCmd<a>{V}}{\getCmd<a>} \equiv \setCmd<a>{V}} : \freeTy{A}}

  \defrule[E-Set-Get-Diff][eq:set-get-diff]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \Sigma \entails{\hasTp{b}{B}} \\
   \left( a \neq b \right) \\
   \Gamma \entails[\Sigma]{\isOfTp{V}{A}}}
  {\Gamma \entails[\Sigma]{\seqCmd*{\setCmd<a>{V}}{\getCmd<b>} \equiv \fletEx*{\getCmd<b>}{x}{\seqCmd*{\setCmd<a>{V}}}{\retCmd*{x}}} : \freeTy{B}}

  \defrule[E-Set-Set-Same][eq:set-set-same]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \Gamma \entails[\Sigma]{\isOfTp{V}{A}} \\
   \Gamma, \isOfTp{x}{A} \entails[\Sigma]{\isOfTp{V'}{A}}
   }
  {\Gamma \entails[\Sigma]{\fletEx*{\setCmd<a>{V}}{x}{\setCmd<a>{V'}} \equiv \letvEx{V}{x}{\setCmd<a>{V'}}} : \freeTy{A}}

  \defrule[E-Set-Set-Diff][eq:set-set-diff]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \Sigma \entails{\hasTp{b}{B}} \\
   \left( a \neq b \right) \\
   \Gamma \entails[\Sigma]{\isOfTp{V}{A}} \\
   \Gamma, \isOfTp{x}{A} \entails[\Sigma]{\isOfTp{V'}{B}}
   }
  {\Gamma \entails[\Sigma]{\fletEx*{\setCmd<a>{V}}{x}{\setCmd<b>{V'}} \equiv \letvEx{V}{x}{\fletEx*{\setCmd<b>{V'}}{y}{\seqCmd*{\setCmd<a>{V}}{\retCmd*{y}}}}} : \freeTy{B}}

  \defrule[E-Get-Set-Same][eq:get-set-same]
  {\Sigma \entails{\hasTp{a}{A}}}
  {\Gamma \entails[\Sigma]{\fletEx*{\getCmd<a>}{x}{\setCmd<a>{x}} \equiv \getCmd<a>} : \freeTy{A}}

  \defrule[E-Get-Get][eq:get-get]
  {\Sigma \entails{\hasTp{a}{A}} \\
   \Sigma \entails{\hasTp{b}{B}}}
  {\Gamma \entails[\Sigma]{\seqCmd*{\getCmd<a>}{\getCmd<b>} \equiv \getCmd<b>} : \freeTy{B}}

\end{mathpar}
We'll see next week how to justify these equations with exact equality.


\end{document}
\documentclass[letterpaper]{article}

\input{setup}
\input{defns}

\usepackage{newunicodechar}
\newunicodechar{∀}{\ensuremath{\mathnormal\forall}}
\newunicodechar{∃}{\ensuremath{\mathnormal\exists}}
\newunicodechar{Γ}{\ensuremath{\mathnormal\Gamma}}

\title{15-791 ATPL \\ Week 8 Notes}
\author{Tesla Zhang, Jason Yao}
\date{\today}

\begin{document}
\maketitle

\section{Call-by-Push-Value (CBPV)}
Last week we introduced the lax framework of computation type.
This week, we introduce another approach to stratify value types and computation types,
called \emph{call-by-push-value} (CBPV), or \emph{polarization}.

Instead of introducing a type former for computation types,
we maintain the distinction between type structures instead.
We consider positive types \emph{values types}, which we denote as $A$,
and negative types \emph{computation types}, which we denote as $X$.
The polarity here is related to the polarity of the corresponding connectives in linear logic.
Similar to adjoint logic, we link these two families of types with an adjunction,
where the computation fragment is similar to the linear fragment in adjoint logic.

The syntax of types in CBPV is given by the following grammar:

\[
    \begin{array}{rcl}
        \text{Computation types} \quad & X ::= & \prodTy*{X_1}{X_2} \mid \parrTy*{A_1}{X_2} \mid F(A) \\
        \text{Value types} \quad       & A ::= & \topTy* \mid \tensorTy*{A_1}{A_2} \mid \sumTy*{A_1}{A_2} \mid U(X) \\
    \end{array}
\]

For simplicity, we introduce the function type only as a computation type,
and for products, we introduce both versions, corresponding to the nature of the product that
it can be used positively or negatively.

\subsection{Statics}

The static semantics of CBPV is defined by the following judgment given by the following typing rules:

\begin{mathpar}
\end{mathpar}

\section{I/O Effects}
We can represent various effects using CBPV as the framework. Here, we represent simple I/O with printing to standard out and reading from standard in.

\subsection{Statics}
Assume we have some type $\kw{string}$. We add the following typing rules to CBPV:

\begin{mathpar}
  \defrule[T-Print][sta:print]
  {\Gamma \entails{\isOfTp{s}{\kw{string}}}}
  {\Gamma \entails{\isOfTp{\kw{print}(s)}{\freeTy{\topTy}}}}

  \defrule[T-Read][sta:read]
  {\strut}
  {\Gamma \entails{\isOfTp{\kw{read}}{\freeTy{\kw{string}}}}}
\end{mathpar}

\subsection{Dynamics}

For values, we use the typical evaluation semantics where $V \evalsTo[] V_0$ for some fully evaluated value $V_0$.

For computations, we describe a configuration/state transition system based on a simplified process calculus. We have three processes $\cal I$, $\cal O$, and $C$ running in parallel composition, written as 
${\cal I} \parallel {\cal O} \parallel C$. $\cal I$ and $\cal O$ are the input and output processes, respectively, and are represented as lists of \kw{string}s. $C$ is the current running computation.

Note that configurations are unique up to structural congruence, so the processes can be freely reordered/nested/etc. as necessary for rules to apply (e.g.  ${\cal I} \parallel {\cal O} \parallel C \equiv {\cal I} \parallel C \parallel {\cal O} \equiv {\cal I} \parallel \left( {\cal O} \parallel C \right)$ ).

Finally, we also have two channels \kw{stdin} and \kw{stdout} which carry data of type \kw{string}.

\subsubsection{Transitions}
We present a subset of the state transitions:
\todo{Needed to use \kw{s} in the step actions instead since $s$ shows up as $\int$ for some reason}
\begin{mathpar}
  \defrule[D-Input][dyn:input]
    {\strut}
    {\consEx*{s}{\cal I} \stepsTo<\sndAc*{\kw{stdin}}{\kw{s}}> {\cal I}}

  \defrule[D-Output][dyn:output]
    {\strut}
    {{\cal O} \stepsTo<\rcvAc*{\kw{stdout}}{\kw{s}}> \consEx*{s}{\cal O}} 

  \defrule[D-Print][dyn:print]
    {\strut}
    {\kw{print}(s) \stepsTo<\sndAc*{\kw{stdout}}{\kw{s}}> {\retEx*{\unitEx*}}}

  \defrule[D-Read][dyn:read]
    {\strut}
    {\kw{read} \stepsTo<\rcvAc*{\kw{stdin}}{\kw{s}}> {\retEx*{s}}}
    
  \defrule[D-Single][dyn:single]
    {S_1 \stepsTo<\alpha> S_1'}
    {S_1 \parallel S_2 \stepsTo<\alpha> S_1' \parallel S_2} 

  \defrule[D-Par][dyn:par]
    {S_1 \stepsTo<\alpha> S_1' \\
     S_2 \stepsTo<\overline{\alpha}> S_2'}
    {S_1 \parallel S_2 \stepsTo S_1' \parallel S_2'} 
  
\end{mathpar}
Note that rule \ruleref{dyn:par} relies on the definition of $\overline{\alpha}$ representing the complementary action of $\alpha$. In this case, $\sndAc*{a}{s}$, the action to send $s$ over channel $a$, and $\rcvAc*{a}{s}$, the action to receive $s$ over channel $a$, are complementary to each other.

The dynamics for I/O are relatively straightforward. If ${\cal I}$ is not empty and the program commands a \kw{read}, \ruleref{dyn:par} allows the overall configuration to take a step by pairing \ruleref{dyn:input} and \ruleref{dyn:read}. Similarly, if the program wishes to \kw{print}, \ruleref{dyn:output} and \ruleref{dyn:print} will apply concurrently.

\ruleref{dyn:single} allows the program to take steps not pertaining to I/O according to the base CBPV dynamics. In this case $\alpha$ would be $\epsilon$, the silent action.

\subsection{Equations}

\section{Mutable State}

\subsection{Grammar}
\subsection{Statics}
\subsection{Dynamics}
\subsection{Equations}

\end{document}